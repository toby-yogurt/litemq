# 时间轮（TimeWheel）示例

这个示例展示了 LiteMQ 中多层时间轮的工作原理。

## 运行示例

```bash
cd examples/timewheel
go run main.go
```

## 示例说明

### 时间轮结构

时间轮是一个环形数组，用于高效地管理和调度延时任务。LiteMQ 使用**多层时间轮**实现从秒级到天级的延时消息：

```
第0层（秒级）- 60个槽位，每个1秒
┌─────┬─────┬─────┬─────┬─────┐
│  0  │  1  │  2  │ ... │ 59  │
└─────┴─────┴─────┴─────┴─────┘
 每秒推进一个槽位

第1层（分钟级）- 60个槽位，每个1分钟
┌─────┬─────┬─────┬─────┬─────┐
│  0  │  1  │  2  │ ... │ 59  │
└─────┴─────┴─────┴─────┴─────┘
 每60秒推进一个槽位

第2层（小时级）- 24个槽位，每个1小时
┌─────┬─────┬─────┬─────┐
│  0  │  1  │  2  │ ... │
└─────┴─────┴─────┴─────┘
 每60分钟推进一个槽位

第3层（天级）- 365个槽位，每个1天
┌─────┬─────┬─────┬─────┐
│  0  │  1  │  2  │ ... │
└─────┴─────┴─────┴─────┘
 每24小时推进一个槽位
```

### 工作原理

1. **添加消息**：根据延时时间选择合适的层级
   - 0-60秒 → 第0层（秒级）
   - 1-60分钟 → 第1层（分钟级）
   - 1-24小时 → 第2层（小时级）
   - 1-365天 → 第3层（天级）

2. **时间推进**：只启动秒级时间轮，每秒推进一个槽位

3. **级联降级**：
   - 当秒级时间轮转完一圈（60秒），推进分钟级时间轮一个槽位
   - 将分钟级时间轮旧槽位的消息降级到秒级时间轮
   - 以此类推，实现从粗粒度到细粒度的精确调度

4. **消息到期**：当消息到期时，触发回调函数

### 示例任务

示例中会添加以下任务：

1. **5秒后执行** - 使用秒级时间轮
2. **10秒后执行** - 使用秒级时间轮
3. **30秒后执行** - 使用秒级时间轮
4. **2分钟后执行** - 使用分钟级时间轮
5. **1小时后执行** - 使用小时级时间轮

### 优势

- **O(1) 时间复杂度**：添加和检查消息都是 O(1)
- **支持超长延时**：从秒级到天级（最长365天）
- **内存高效**：只存储消息偏移量，不存储完整消息
- **精确调度**：秒级精度的延时投递

## 代码说明

```go
// 1. 创建时间轮
timeWheel := broker.NewTimeWheel()

// 2. 设置到期回调
timeWheel.SetExpireCallback(func(offset int64) {
    // 处理到期消息
})

// 3. 启动时间轮
timeWheel.Start()

// 4. 添加延时消息
delayTime := time.Now().Add(5 * time.Second).UnixMilli()
timeWheel.AddMessage(delayTime, taskOffset)

// 5. 停止时间轮
timeWheel.Stop()
```

