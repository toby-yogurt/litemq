# LiteMQ 企业级消息队列系统 - 技术方案

## 目录

1. [项目概述](https://claude.ai/chat/da406293-5476-40da-b3b8-bbca9a46a817#1-%E9%A1%B9%E7%9B%AE%E6%A6%82%E8%BF%B0)
2. [整体架构设计](https://claude.ai/chat/da406293-5476-40da-b3b8-bbca9a46a817#2-%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1)
3. [核心模块详细设计](https://claude.ai/chat/da406293-5476-40da-b3b8-bbca9a46a817#3-%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1)
4. [存储架构设计](https://claude.ai/chat/da406293-5476-40da-b3b8-bbca9a46a817#4-%E5%AD%98%E5%82%A8%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1)
5. [事务消息设计](https://claude.ai/chat/da406293-5476-40da-b3b8-bbca9a46a817#5-%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF%E8%AE%BE%E8%AE%A1)
6. [广播消息设计](https://claude.ai/chat/da406293-5476-40da-b3b8-bbca9a46a817#6-%E5%B9%BF%E6%92%AD%E6%B6%88%E6%81%AF%E8%AE%BE%E8%AE%A1)
7. [集群架构设计](https://claude.ai/chat/da406293-5476-40da-b3b8-bbca9a46a817#7-%E9%9B%86%E7%BE%A4%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1)
8. [主从复制设计](https://claude.ai/chat/da406293-5476-40da-b3b8-bbca9a46a817#8-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E8%AE%BE%E8%AE%A1)
9. [高可用方案设计](https://claude.ai/chat/da406293-5476-40da-b3b8-bbca9a46a817#9-%E9%AB%98%E5%8F%AF%E7%94%A8%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1)
10. [性能优化方案](https://claude.ai/chat/da406293-5476-40da-b3b8-bbca9a46a817#10-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88)
11. [监控与运维](https://claude.ai/chat/da406293-5476-40da-b3b8-bbca9a46a817#11-%E7%9B%91%E6%8E%A7%E4%B8%8E%E8%BF%90%E7%BB%B4)
12. [项目结构设计](https://claude.ai/chat/da406293-5476-40da-b3b8-bbca9a46a817#12-%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1)

---

## 1. 项目概述

### 1.1 项目定位

LiteMQ 是一个**轻量级、高性能、企业级**的分布式消息队列系统，参考 RocketMQ 和 Kafka 的设计理念，提供：

* ✅ 高性能：单机支持 10万+ QPS
* ✅ 高可靠：消息不丢失，支持主从复制
* ✅ 高可用：支持集群部署，故障自动切换
* ✅ 事务消息：支持分布式事务
* ✅ 广播消费：支持消息广播
* ✅ 延时消息：支持任意时间延时
* ✅ 顺序消息：支持全局和分区顺序
* ✅ 消息重试：智能重试机制

### 1.2 技术选型

| 组件     | 技术选型                 | 理由                       |
| ---------- | -------------------------- | ---------------------------- |
| 开发语言 | Go 1.21+                 | 高性能、并发友好、部署简单 |
| 存储引擎 | CommitLog + ConsumeQueue | 顺序写、高性能             |
| 网络通信 | gRPC + HTTP              | 高效、跨语言               |
| 序列化   | Protocol Buffers         | 高效、向后兼容             |
| 注册中心 | 内置 NameServer          | 无外部依赖                 |
| 配置管理 | TOML/YAML                | 简单易用                   |

### 1.3 核心指标

| 指标       | 目标值     | 说明                |
| ------------ | ------------ | --------------------- |
| 吞吐量     | 10万+ QPS  | 单 Broker 性能      |
| 延迟       | P99 < 10ms | 消息端到端延迟      |
| 可用性     | 99.99%     | 年停机时间 < 53分钟 |
| 数据可靠性 | 99.9999%   | 数据不丢失          |
| 消息堆积   | 千万级     | 支持大量消息堆积    |

---

## 2. 整体架构设计

### 2.1 架构全景图

```
┌─────────────────────────────────────────────────────────────────┐
│                    Client Layer (SDK)                            │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐          │
│  │   Producer   │  │   Consumer   │  │    Admin     │          │
│  └──────┬───────┘  └──────┬───────┘  └──────┬───────┘          │
└─────────┼──────────────────┼──────────────────┼─────────────────┘
          │                  │                  │
          │  ┌───────────────┼──────────────────┼───────────────┐
          │  │               │                  │               │
          ▼  ▼               ▼                  ▼               │
┌────────────────────────────────────────────────────────────┐  │
│              NameServer Cluster (服务注册与发现)            │  │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐                 │  │
│  │   NS-1   │  │   NS-2   │  │   NS-3   │  (无状态集群)   │  │
│  └──────────┘  └──────────┘  └──────────┘                 │  │
│                                                             │  │
│  功能：Broker注册、路由管理、负载均衡、故障检测           │  │
└─────────────────────┬───────────────────────────────────────┘  │
                      │ 心跳/注册                                 │
          ┌───────────┼─────────────┬─────────────────────────┐  │
          │           │             │                         │  │
          ▼           ▼             ▼                         │  │
┌─────────────────────────────────────────────────────────┐  │  │
│                  Broker Cluster (主从架构)               │  │  │
│                                                           │  │  │
│  ┌─────────────────┐  ┌─────────────────┐               │  │  │
│  │  Broker-A       │  │  Broker-B       │  ...          │  │  │
│  │  ┌───────────┐  │  │  ┌───────────┐  │               │  │  │
│  │  │  Master   │  │  │  │  Master   │  │               │  │  │
│  │  │  (读写)   │  │  │  │  (读写)   │  │               │  │  │
│  │  └─────┬─────┘  │  │  └─────┬─────┘  │               │  │  │
│  │        │        │  │        │        │               │  │  │
│  │  ┌─────▼─────┐  │  │  ┌─────▼─────┐  │               │  │  │
│  │  │  Slave-1  │  │  │  │  Slave-1  │  │               │  │  │
│  │  │  (只读)   │  │  │  │  (只读)   │  │               │  │  │
│  │  └───────────┘  │  │  └───────────┘  │               │  │  │
│  │  ┌───────────┐  │  │  ┌───────────┐  │               │  │  │
│  │  │  Slave-2  │  │  │  │  Slave-2  │  │               │  │  │
│  │  │  (只读)   │  │  │  │  (只读)   │  │               │  │  │
│  │  └───────────┘  │  │  └───────────┘  │               │  │  │
│  └─────────────────┘  └─────────────────┘               │  │  │
│                                                           │  │  │
│  功能：消息存储、消息分发、事务协调、延时调度            │  │  │
└───────────────────────────────────────────────────────────┘  │  │
                                                               │  │
                                                               │  │
          ┌────────────────────────────────────────────────────┘  │
          │                                                        │
          ▼                                                        │
┌─────────────────────────────────────────────────────────┐      │
│              Storage Layer (存储层)                      │      │
│                                                           │      │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  │      │
│  │  CommitLog   │  │ ConsumeQueue │  │  IndexFile   │  │      │
│  │  (消息主存储) │  │  (消费索引)   │  │  (索引文件)   │  │      │
│  └──────────────┘  └──────────────┘  └──────────────┘  │      │
│                                                           │      │
│  磁盘存储：顺序写、MMap、零拷贝                           │      │
└───────────────────────────────────────────────────────────┘      │
                                                                   │
                                                                   │
┌─────────────────────────────────────────────────────────┐      │
│          Infrastructure Layer (基础设施)                 │◀─────┘
│                                                           │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  │
│  │  Monitoring  │  │    Metrics   │  │   Tracing    │  │
│  │  (监控告警)   │  │   (指标采集)  │  │  (链路追踪)   │  │
│  └──────────────┘  └──────────────┘  └──────────────┘  │
└───────────────────────────────────────────────────────────┘
```

### 2.2 分层设计

#### 2.2.1 接入层 (Client Layer)

* ​**Producer SDK**​: 消息发送、事务消息、延时消息
* ​**Consumer SDK**​: 消息消费、广播消费、顺序消费
* ​**Admin SDK**​: 集群管理、Topic管理、监控查询

#### 2.2.2 路由层 (NameServer)

* ​**服务注册**​: Broker注册、心跳维持
* ​**路由管理**​: Topic路由信息、队列分配
* ​**负载均衡**​: Broker选择、队列分配
* ​**故障检测**​: 心跳超时检测、故障切换

#### 2.2.3 服务层 (Broker)

* ​**消息接收**​: 消息接收、消息验证
* ​**消息存储**​: CommitLog写入、索引构建
* ​**消息分发**​: Push/Pull模式、消息过滤
* ​**事务协调**​: 事务消息、回查机制
* ​**延时调度**​: 延时消息、定时消息

#### 2.2.4 存储层 (Storage)

* ​**CommitLog**​: 消息主存储(顺序写)
* ​**ConsumeQueue**​: 消费队列索引
* ​**IndexFile**​: 消息索引文件
* ​**CheckPoint**​: 检查点文件

---

## 3. 核心模块详细设计

### 3.1 NameServer 模块

#### 3.1.1 功能职责

```
┌─────────────────────────────────────────────────────────┐
│                  NameServer 核心功能                     │
├─────────────────────────────────────────────────────────┤
│                                                          │
│  1. 服务注册与发现                                       │
│     - Broker注册/注销                                   │
│     - Topic注册                                         │
│     - 路由信息维护                                       │
│                                                          │
│  2. 心跳管理                                             │
│     - 接收Broker心跳                                    │
│     - 超时检测                                          │
│     - 状态更新                                          │
│                                                          │
│  3. 路由管理                                             │
│     - Topic路由信息                                     │
│     - 队列分配信息                                       │
│     - Broker地址信息                                    │
│                                                          │
│  4. 负载均衡                                             │
│     - Broker选择策略                                    │
│     - 队列分配策略                                       │
│                                                          │
│  5. 故障检测                                             │
│     - 心跳超时检测                                       │
│     - Broker下线处理                                    │
│     - 主从切换通知                                       │
│                                                          │
└─────────────────────────────────────────────────────────┘
```

#### 3.1.2 数据结构设计

```go
// NameServer 核心数据结构

// Broker信息表
BrokerTable: map[string]*BrokerInfo {
    "broker-001": {
        BrokerID: "broker-001",
        BrokerName: "broker-a",
        ClusterName: "default-cluster",
        Role: Master,
        Address: "192.168.1.100:9876",
        Status: Online,
        LastHeartbeat: 1702800000,
        Slaves: ["broker-001-s1", "broker-001-s2"]
    },
    ...
}

// Topic路由表
TopicRouteTable: map[string]*RouteInfo {
    "order-topic": {
        BrokerDatas: [
            {
                BrokerName: "broker-a",
                BrokerAddrs: {
                    0: "192.168.1.100:9876",  // Master
                    1: "192.168.1.101:9876",  // Slave-1
                    2: "192.168.1.102:9876",  // Slave-2
                }
            }
        ],
        QueueDatas: [
            {
                BrokerName: "broker-a",
                ReadQueueNums: 8,
                WriteQueueNums: 8,
                Perm: 6  // 读写权限
            }
        ]
    },
    ...
}

// 集群表
ClusterTable: map[string]map[string]*BrokerInfo {
    "default-cluster": {
        "broker-a": *BrokerInfo,
        "broker-b": *BrokerInfo,
        ...
    }
}
```

#### 3.1.3 心跳机制

```
时序图：

Broker                    NameServer
  │                            │
  │──── Heartbeat ────────────>│  每10秒发送心跳
  │                            │
  │<───── ACK ────────────────│
  │                            │
  │                            │  超时检测(30秒)
  │                            │
  │  X  网络故障               │
  │                            │
  │                            │  30秒后标记下线
  │                            │
  │                            │──> 触发主从切换
  │                            │
```

​**心跳协议**​:

```protobuf
message HeartbeatRequest {
    string broker_id = 1;
    string broker_name = 2;
    string cluster_name = 3;
    string address = 4;
    BrokerRole role = 5;
    map<string, QueueInfo> queue_info = 6;
    int64 timestamp = 7;
}

message HeartbeatResponse {
    int32 code = 1;
    string message = 2;
}
```

#### 3.1.4 故障检测与切换

```
故障检测流程：

1. 心跳超时检测
   ├─ 扫描周期: 10秒
   ├─ 超时阈值: 30秒
   └─ 状态更新: Online -> Offline

2. Master故障处理
   ├─ 检测Master下线
   ├─ 查找可用Slave
   ├─ 提升Slave为Master
   ├─ 更新路由信息
   └─ 通知所有客户端

3. Slave故障处理
   ├─ 检测Slave下线
   ├─ 从路由表移除
   └─ 不影响服务

4. 全部故障处理
   ├─ 所有副本下线
   ├─ Topic不可用
   └─ 客户端报错
```

### 3.2 Broker 模块

#### 3.2.1 Broker 架构

```
┌────────────────────────────────────────────────────────────┐
│                     Broker 内部架构                         │
├────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌─────────────────────────────────────────────────────┐  │
│  │              Network Layer (网络层)                  │  │
│  │  ┌──────────┐  ┌──────────┐  ┌──────────┐          │  │
│  │  │  gRPC    │  │   HTTP   │  │   TCP    │          │  │
│  │  └──────────┘  └──────────┘  └──────────┘          │  │
│  └─────────────────────────────────────────────────────┘  │
│                           │                                │
│  ┌─────────────────────────────────────────────────────┐  │
│  │           Business Layer (业务层)                    │  │
│  │                                                       │  │
│  │  ┌──────────────┐  ┌──────────────┐                │  │
│  │  │ SendMessage  │  │PullMessage   │                │  │
│  │  │   Handler    │  │   Handler    │                │  │
│  │  └──────────────┘  └──────────────┘                │  │
│  │                                                       │  │
│  │  ┌──────────────┐  ┌──────────────┐                │  │
│  │  │ Transaction  │  │    Delay     │                │  │
│  │  │   Service    │  │   Service    │                │  │
│  │  └──────────────┘  └──────────────┘                │  │
│  │                                                       │  │
│  │  ┌──────────────┐  ┌──────────────┐                │  │
│  │  │  Replication │  │  Consumer    │                │  │
│  │  │   Service    │  │   Manager    │                │  │
│  │  └──────────────┘  └──────────────┘                │  │
│  └─────────────────────────────────────────────────────┘  │
│                           │                                │
│  ┌─────────────────────────────────────────────────────┐  │
│  │           Storage Layer (存储层)                     │  │
│  │                                                       │  │
│  │  ┌──────────────┐  ┌──────────────┐                │  │
│  │  │  CommitLog   │  │ConsumeQueue  │                │  │
│  │  │   Manager    │  │   Manager    │                │  │
│  │  └──────────────┘  └──────────────┘                │  │
│  │                                                       │  │
│  │  ┌──────────────┐  ┌──────────────┐                │  │
│  │  │  IndexFile   │  │ CheckPoint   │                │  │
│  │  │   Manager    │  │   Manager    │                │  │
│  │  └──────────────┘  └──────────────┘                │  │
│  └─────────────────────────────────────────────────────┘  │
│                                                             │
└────────────────────────────────────────────────────────────┘
```

#### 3.2.2 消息发送流程

```
Producer                  Broker-Master              Broker-Slave
   │                           │                           │
   │──1. SendMessage ──────────>│                          │
   │   (包含消息体)              │                          │
   │                           │                           │
   │                           │──2. 验证消息              │
   │                           │   - Topic是否存在         │
   │                           │   - 消息大小检查          │
   │                           │   - 权限验证              │
   │                           │                           │
   │                           │──3. 写入CommitLog ────────>│
   │                           │   (顺序写入)              │  (主从复制)
   │                           │                           │
   │                           │<─4. 复制确认 ─────────────│
   │                           │                           │
   │                           │──5. 构建ConsumeQueue     │
   │                           │   索引                    │
   │                           │                           │
   │                           │──6. 刷盘                  │
   │                           │   - 同步刷盘 or          │
   │                           │   - 异步刷盘              │
   │                           │                           │
   │<──7. Response ────────────│                          │
   │   (返回Offset)             │                          │
   │                           │                           │
```

​**同步复制 vs 异步复制**​:

```
┌──────────────────┬─────────────────┬─────────────────┐
│      特性        │    同步复制     │    异步复制     │
├──────────────────┼─────────────────┼─────────────────┤
│  可靠性          │  极高           │  高             │
│  性能            │  中等           │  高             │
│  延迟            │  较高(等待Slave)│  低             │
│  适用场景        │  金融、支付     │  日志、监控     │
│  数据丢失风险    │  极低           │  Master宕机丢失 │
└──────────────────┴─────────────────┴─────────────────┘
```

#### 3.2.3 消息消费流程

```
Consumer                  Broker
   │                         │
   │──1. PullMessage ────────>│
   │   (指定Topic、Queue)     │
   │                         │
   │                         │──2. 查询ConsumeQueue
   │                         │   获取消息位置
   │                         │
   │                         │──3. 从CommitLog读取
   │                         │   消息内容
   │                         │
   │                         │──4. 消息过滤
   │                         │   (Tag/SQL过滤)
   │                         │
   │<──5. Response ───────────│
   │   (返回消息列表)         │
   │                         │
   │──6. ACK ─────────────────>│
   │   (确认消费)             │
   │                         │
   │                         │──7. 更新消费进度
   │                         │
```

---

## 4. 存储架构设计

### 4.1 存储整体架构

```
数据存储目录结构:

litemq-store/
├── commitlog/                  # 消息主存储
│   ├── 00000000000000000000   # 第1个文件(1GB)
│   ├── 00000000001073741824   # 第2个文件(1GB)
│   └── 00000000002147483648   # 第3个文件(1GB)
│
├── consumequeue/               # 消费队列索引
│   ├── topic-order/
│   │   ├── 0/                 # 队列0
│   │   │   ├── 00000000000000000000
│   │   │   └── 00000000000006000000
│   │   ├── 1/                 # 队列1
│   │   └── 2/                 # 队列2
│   └── topic-payment/
│
├── index/                      # 消息索引
│   ├── 20241216000000
│   └── 20241217000000
│
├── checkpoint/                 # 检查点
│   └── checkpoint
│
├── config/                     # 配置文件
│   ├── topics.json
│   ├── subscriptions.json
│   └── delayOffset.json
│
└── abort/                      # 异常标记
    └── abort
```

### 4.2 CommitLog 详细设计

#### 4.2.1 文件结构

```
CommitLog File (1GB固定大小):

┌────────────────────────────────────────────────────────────┐
│  Physical Offset: 0                                         │
├────────────────────────────────────────────────────────────┤
│  Message 1:                                                 │
│  ┌──────────────────────────────────────────────────────┐  │
│  │ Message Header (48 bytes)                            │  │
│  ├──────────────────────────────────────────────────────┤  │
│  │ Message Body (variable length)                       │  │
│  ├──────────────────────────────────────────────────────┤  │
│  │ Message Properties (variable length)                 │  │
│  └──────────────────────────────────────────────────────┘  │
├────────────────────────────────────────────────────────────┤
│  Message 2: ...                                             │
├────────────────────────────────────────────────────────────┤
│  Message 3: ...                                             │
├────────────────────────────────────────────────────────────┤
│  ...                                                        │
└────────────────────────────────────────────────────────────┘
```

#### 4.2.2 消息格式详解

```
Message Header (固定48字节):

┌─────────────────────────────────────────────────────────┐
│ Offset  │ Length │ Field             │ Description      │
├─────────┼────────┼───────────────────┼──────────────────┤
│ 0-3     │ 4      │ TotalSize         │ 消息总长度       │
│ 4-7     │ 4      │ MagicCode         │ 魔数(0xAABBCCDD) │
│ 8-11    │ 4      │ BodyCRC           │ 消息体CRC校验    │
│ 12-15   │ 4      │ QueueID           │ 队列ID           │
│ 16-19   │ 4      │ Flag              │ 消息标志         │
│ 20-27   │ 8      │ QueueOffset       │ 队列逻辑偏移     │
│ 28-35   │ 8      │ PhysicalOffset    │ 物理偏移         │
│ 36-39   │ 4      │ SysFlag           │ 系统标志         │
│ 40-47   │ 8      │ BornTimestamp     │ 消息生成时间     │
│ 48-55   │ 8      │ StoreTimestamp    │ 存储时间         │
└─────────┴────────┴───────────────────┴──────────────────┘

Message Body (变长):
┌─────────────────────────────────────────────────────────┐
│ TopicLength(1) │ Topic(N) │ BodyLength(4) │ Body(N)   │
└─────────────────────────────────────────────────────────┘

Message Properties (变长):
┌─────────────────────────────────────────────────────────┐
│ PropertiesLength(2) │ Properties(N)                     │
│ Format: key1\u0001value1\u0002key2\u0001value2...        │
└─────────────────────────────────────────────────────────┘
```

#### 4.2.3 写入策略

```
写入性能优化:

1. 顺序写入
   ├─ 追加写入模式
   ├─ 避免随机IO
   └─ 充分利用磁盘顺序写性能

2. 内存映射 (MMap)
   ├─ 使用MappedByteBuffer
   ├─ 减少系统调用
   └─ 利用操作系统PageCache

3. 刷盘策略
   ├─ 同步刷盘: 每条消息立即刷盘
   ├─ 异步刷盘: 定时批量刷盘(默认500ms)
   └─ GroupCommit: 组提交优化

4. 文件预分配
   ├─ 启动时预分配文件
   ├─ 避免动态扩展
   └─ 减少文件碎片
```

​**刷盘对比**​:

```
┌──────────────┬────────────┬────────────┬─────────────┐
│   刷盘方式   │   性能     │  可靠性    │   适用场景  │
├──────────────┼────────────┼────────────┼─────────────┤
│ 同步刷盘     │ 1000 TPS   │ 极高       │ 金融交易    │
│ 异步刷盘     │ 10万+ TPS  │ 高         │ 日志收集    │
│ 组提交       │ 5万 TPS    │ 很高       │ 通用场景    │
└──────────────┴────────────┴────────────┴─────────────┘
```

### 4.3 ConsumeQueue 详细设计

#### 4.3.1 索引结构

```
ConsumeQueue File (每个文件600万条索引):

每条索引固定20字节:
┌──────────────────────────────────────────────────────┐
│ Offset  │ Length │ Field             │ Description  │
├─────────┼────────┼───────────────────┼──────────────┤
│ 0-7     │ 8      │ PhysicalOffset    │ CommitLog物理偏移 │
│ 8-11    │ 4      │ Size              │ 消息大小     │
│ 12-19   │ 8      │ TagsCode          │ 消息Tag哈希码│
└─────────┴────────┴───────────────────┴──────────────┘

作用:
1. 快速定位消息在CommitLog中的位置
2. 支持按队列消费
3. 支持消息过滤(基于Tag)
```

#### 4.3.2 构建流程

```
CommitLog写入后异步构建ConsumeQueue:

CommitLog                ConsumeQueue Builder          ConsumeQueue
    │                           │                           │
    │──1. 消息写入 ──────────────>│                          │
    │                           │                           │
    │                           │──2. 解析消息               │
    │                           │   - Topic                 │
    │                           │   - QueueID               │
    │                           │   - PhysicalOffset        │
    │                           │   - Size                  │
    │                           │   - TagsCode              │
    │                           │                           │
    │                           │──3. 构建索引 ──────────────>│
    │                           │                           │
    │                           │                           │──4. 写入文件
    │                           │                           │
```

### 4.4 IndexFile 设计

#### 4.4.1 索引用途

```
支持按 Key 或 时间范围 查询消息:

1. 按Key查询
   - 订单号查询订单消息
   - 用户ID查询用户消息

2. 按时间范围查询
   - 查询某个时间段的消息
   - 消息审计、问题排查
```

#### 4.4.2 索引结构

```
IndexFile (Hash索引):

┌────────────────────────────────────────────────────────┐
│  Index Header (40 bytes)                               │
├────────────────────────────────────────────────────────┤
│  Hash Slots (500万个槽位, 每个4字节)                  │
├────────────────────────────────────────────────────────┤
│  Index Linked List (2000万条索引, 每个20字节)         │
└────────────────────────────────────────────────────────┘

Index Entry (20字节):
┌─────────────────────────────────────────────────────┐
│ KeyHash(4) │ PhyOffset(8) │ TimeDiff(4) │ Next(4) │
└─────────────────────────────────────────────────────┘
```

---

## 5. 事务消息设计

### 5.1 事务消息原理

```
分布式事务场景:

┌──────────────┐       ┌──────────────┐      ┌──────────────┐
│   订单服务   │       │    LiteMQ    │      │   库存服务   │
└──────┬───────┘       └──────┬───────┘      └──────┬───────┘
       │                      │                     │
       │──1. 发送Half消息 ────>│                    │
       │   (Prepare状态)       │                    │
       │                      │                    │
       │<─2. ACK ─────────────│                    │
       │                      │                    │
       │──3. 执行本地事务      │                    │
       │   (扣减订单金额)      │                    │
       │                      │                    │
       │──4. Commit/Rollback ─>│                    │
       │                      │                    │
       │                      │──5. 消息可见 ───────>│
       │                      │                    │
       │                      │<─6. 消费消息 ────────│
       │                      │   (扣减库存)        │
```

### 5.2 事务状态机

```
消息状态流转:

Unknown ──> Prepared ──> Committed ──> Consumed
              │            
              └─────────> RollbackRequested ──> Deleted

状态说明:
- Unknown: 初始状态
- Prepared: 预提交(Half消息)
- Committed: 已提交(消息可见)
- RollbackRequested: 回滚中
- Deleted: 已删除
- Consumed: 已消费
```

### 5.3 事务回查机制

```
回查流程:

Broker                      Producer
  │                            │
  │──1. 定时扫描未决事务 ──────>│
  │   (Prepared状态超过60秒)   │
  │                            │
  │<──2. 查询本地事务状态 ──────│
  │   (Commit/Rollback/Unknown)│
  │                            │
  │──3. 根据状态处理           │
  │   - Commit: 消息可见       │
  │   - Rollback: 删除消息     │
  │   - Unknown: 继续等待       │
  │                            │

回查策略:
- 首次回查: 60秒后
- 回查间隔: 60秒
- 最大回查次数: 15次
- 超过次数: 删除消息
```

### 5.4 事务消息实现要点

```
1. Half消息存储
   ├─ 存储到特殊Topic: RMQ_SYS_TRANS_HALF_TOPIC
   ├─ 对消费者不可见
   └─ 等待Commit/Rollback

2. Op消息
   ├─ 记录事务操作(Commit/Rollback)
   ├─ Topic: RMQ_SYS_TRANS_OP_HALF_TOPIC
   └─ 用于幂等性保证

3. 消息可见性
   ├─ Commit后移动到真实Topic
   ├─ 构建ConsumeQueue索引
   └─ 消费者可见

4. 回查状态存储
   ├─ 本地事务表
   ├─ 事务ID关联
   └─ 状态持久化
```

---

## 6. 广播消息设计

### 6.1 广播 vs 集群消费

```
┌──────────────────┬─────────────────┬─────────────────┐
│   消费模式       │   集群消费      │   广播消费      │
├──────────────────┼─────────────────┼─────────────────┤
│ 消费者关系       │ 负载均衡        │ 独立消费        │
│ 消息分配         │ 队列分配        │ 全部消费        │
│ 消费进度存储     │ Broker端        │ 客户端          │
│ 消息重复         │ 不重复          │ 每个都收到      │
│ 消费失败重试     │ 支持            │ 客户端控制      │
│ 消费速度         │ 快(并行)        │ 慢(串行)        │
│ 适用场景         │ 任务分发        │ 配置刷新        │
│                 │ 负载均衡        │ 缓存更新        │
│                 │                │ 本地计算        │
└──────────────────┴─────────────────┴─────────────────┘
```

### 6.2 广播消费实现

```
架构设计:

Topic: config-update

┌─────────────────────────────────────────────────────┐
│                   Broker                             │
│                                                      │
│  ┌────────────────────────────────────────────────┐ │
│  │  ConsumeQueue (每个Consumer独立队列)           │ │
│  │                                                 │ │
│  │  Consumer-A-Queue: [Msg1, Msg2, Msg3, ...]    │ │
│  │  Consumer-B-Queue: [Msg1, Msg2, Msg3, ...]    │ │
│  │  Consumer-C-Queue: [Msg1, Msg2, Msg3, ...]    │ │
│  └────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────┘
         │              │              │
         ▼              ▼              ▼
    Consumer-A     Consumer-B     Consumer-C
    (全部消费)     (全部消费)     (全部消费)

实现方式:
1. 消息写入CommitLog(同集群模式)
2. 为每个Consumer创建独立ConsumeQueue
3. 消费进度存储在Consumer本地
4. Consumer断线重连后从本地进度消费
```

### 6.3 消费进度管理

```
集群模式:
┌─────────────────────────────────────────────────┐
│  Broker端存储消费进度                            │
│                                                  │
│  ConsumerGroup: order-consumer-group             │
│  ├─ Queue-0: Offset=1000                        │
│  ├─ Queue-1: Offset=2000                        │
│  └─ Queue-2: Offset=1500                        │
└─────────────────────────────────────────────────┘

广播模式:
┌─────────────────────────────────────────────────┐
│  Consumer本地存储消费进度                        │
│                                                  │
│  ~/.litemq/offsets/                             │
│  ├─ topic-config-update.json                    │
│  │   {                                          │
│  │     "queue_0": 1000,                         │
│  │     "queue_1": 2000                          │
│  │   }                                          │
└─────────────────────────────────────────────────┘
```

---

## 7. 集群架构设计

### 7.1 集群拓扑

```
多Broker集群:

┌────────────────────────────────────────────────────┐
│              NameServer Cluster                     │
│   ┌──────────┐  ┌──────────┐  ┌──────────┐        │
│   │  NS-1    │  │  NS-2    │  │  NS-3    │        │
│   └──────────┘  └──────────┘  └──────────┘        │
└────────────┬───────────┬───────────┬───────────────┘
             │           │           │
    ┌────────┴─────┬─────┴──────┬────┴──────────┐
    │              │            │               │
    ▼              ▼            ▼               ▼
┌─────────┐  ┌─────────┐  ┌─────────┐    ┌─────────┐
│Broker-A │  │Broker-B │  │Broker-C │    │Broker-D │
│ Master  │  │ Master  │  │ Master  │    │ Master  │
│         │  │         │  │         │    │         │
│ ┌─────┐ │  │ ┌─────┐ │  │ ┌─────┐ │    │ ┌─────┐ │
│ │Slave│ │  │ │Slave│ │  │ │Slave│ │    │ │Slave│ │
│ └─────┘ │  │ └─────┘ │  │ └─────┘ │    │ └─────┘ │
└─────────┘  └─────────┘  └─────────┘    └─────────┘
```

### 7.2 Topic分片策略

```
Topic队列分布:

Topic: order-topic (16个队列)

分布策略1: 平均分布
┌──────────────────────────────────────────────┐
│ Broker-A: Queue 0, 1, 2, 3                   │
│ Broker-B: Queue 4, 5, 6, 7                   │
│ Broker-C: Queue 8, 9, 10, 11                 │
│ Broker-D: Queue 12, 13, 14, 15               │
└──────────────────────────────────────────────┘

分布策略2: 主题独占
┌──────────────────────────────────────────────┐
│ Broker-A: order-topic (全部16个队列)         │
│ Broker-B: payment-topic (8个队列)            │
│ Broker-C: user-topic (4个队列)               │
│ Broker-D: log-topic (32个队列)               │
└──────────────────────────────────────────────┘

分布策略3: 混合模式
┌──────────────────────────────────────────────┐
│ Broker-A: order (Q0-3), payment (Q0-1)       │
│ Broker-B: order (Q4-7), user (Q0-3)          │
│ Broker-C: order (Q8-11), log (Q0-15)         │
│ Broker-D: order (Q12-15), payment (Q2-7)     │
└──────────────────────────────────────────────┘
```

### 7.3 负载均衡策略

```
Producer端负载均衡:

1. 轮询策略 (RoundRobin)
   Queue 0 -> Broker-A
   Queue 1 -> Broker-A
   Queue 2 -> Broker-A
   Queue 3 -> Broker-A
   Queue 4 -> Broker-B
   ...

2. 随机策略 (Random)
   随机选择Broker和Queue

3. 哈希策略 (Hash)
   hash(MessageKey) % QueueCount
   保证同一Key的消息进入同一队列

4. 最小延迟策略 (LatencyAware)
   选择响应时间最短的Broker

Consumer端负载均衡:

1. 平均分配 (AVG)
   Consumer数 = 3, Queue数 = 8
   C1: Q0, Q1, Q2
   C2: Q3, Q4, Q5
   C3: Q6, Q7

2. 一致性哈希 (ConsistentHash)
   减少Rebalance时的队列迁移

3. 机房优先 (IDCAware)
   优先消费同机房的队列
```

---

## 8. 主从复制设计

### 8.1 主从架构

```
Master-Slave架构:

┌─────────────────────────────────────────────────┐
│                  Master                          │
│  ┌───────────────────────────────────────────┐  │
│  │  1. 接收写请求                            │  │
│  │  2. 写入CommitLog                         │  │
│  │  3. 构建ConsumeQueue                      │  │
│  │  4. 主从复制                              │  │
│  │  5. 返回客户端                            │  │
│  └───────────────────────────────────────────┘  │
└──────────────────┬──────────────────────────────┘
                   │ 复制数据
         ┌─────────┼─────────┐
         │                   │
         ▼                   ▼
┌──────────────────┐  ┌──────────────────┐
│    Slave-1       │  │    Slave-2       │
│  ┌────────────┐  │  │  ┌────────────┐  │
│  │ 接收复制   │  │  │  │ 接收复制   │  │
│  │ 写入数据   │  │  │  │ 写入数据   │  │
│  │ 提供读服务 │  │  │  │ 提供读服务 │  │
│  └────────────┘  │  │  └────────────┘  │
└──────────────────┘  └──────────────────┘
```

### 8.2 复制协议

```
同步复制流程:

Master                   Slave-1                 Slave-2
  │                        │                       │
  │──1. 写入CommitLog ──────>│──────────────────────>│
  │   (包含Offset)          │                       │
  │                        │                       │
  │                        │──2. 写入本地CommitLog  │
  │                        │                       │──2. 写入本地
  │                        │                       │
  │<───3. ACK ─────────────│<──────────────────────│
  │                        │                       │
  │──4. 返回Producer ───────>│                      │
  │                        │                       │

异步复制流程:

Master                   Slave
  │                        │
  │──1. 写入CommitLog      │
  │                        │
  │──2. 立即返回Producer ───>│
  │                        │
  │──3. 后台异步复制 ───────>│
  │                        │
  │                        │──4. 写入本地
  │                        │
  │<───5. ACK ─────────────│
  │                        │
```

### 8.3 复制数据结构

```
复制请求:

message ReplicationRequest {
    int64 master_offset = 1;      // Master当前Offset
    int64 slave_max_offset = 2;   // Slave已复制Offset
    repeated MessageData messages = 3;
}

message MessageData {
    int64 physical_offset = 1;
    int32 size = 2;
    bytes data = 3;
}

复制响应:

message ReplicationResponse {
    int64 slave_max_offset = 1;   // Slave复制后的Offset
    int32 code = 2;
    string message = 3;
}
```

### 8.4 主从切换

```
Master故障切换流程:

1. 故障检测
   ├─ NameServer检测Master心跳超时
   ├─ Slave检测与Master连接断开
   └─ 触发切换流程

2. Slave选举
   ├─ 选择Offset最大的Slave
   ├─ 选择优先级最高的Slave
   └─ 手动指定Slave

3. Slave升级为Master
   ├─ 修改角色为Master
   ├─ 开启写入权限
   ├─ 向NameServer注册为Master
   └─ 更新路由信息

4. 客户端切换
   ├─ Producer获取新的Master地址
   ├─ Consumer获取新的Master地址
   └─ 继续正常服务

5. 旧Master恢复
   ├─ 检测到新Master存在
   ├─ 自动降级为Slave
   └─ 从新Master同步数据
```

### 8.5 数据一致性保证

```
一致性级别:

1. 强一致性 (同步复制 + 同步刷盘)
   ├─ Master写入并刷盘
   ├─ Slave写入并刷盘
   ├─ 都成功才返回
   └─ 适用: 金融交易

2. 最终一致性 (异步复制 + 异步刷盘)
   ├─ Master写入即返回
   ├─ 后台异步复制
   ├─ 后台异步刷盘
   └─ 适用: 日志收集

3. 半同步 (同步复制 + 异步刷盘)
   ├─ Master写入
   ├─ Slave写入内存
   ├─ 返回成功
   └─ 适用: 通用场景

数据不一致处理:

1. Master-Slave数据差异
   ├─ Slave追赶Master
   ├─ 从差异点开始复制
   └─ 保证最终一致

2. 脑裂问题
   ├─ 多个Master并存
   ├─ NameServer仲裁
   ├─ 选择Offset最大的
   └─ 其他降级为Slave
```

---

## 9. 高可用方案设计

### 9.1 高可用架构

```
多机房部署:

┌─────────────────────────────────────────────────────┐
│               Region: Beijing                        │
│                                                      │
│  ┌──────────────────┐      ┌──────────────────┐    │
│  │   AZ-1 (机房1)   │      │   AZ-2 (机房2)   │    │
│  │                  │      │                  │    │
│  │  ┌────────────┐  │      │  ┌────────────┐  │    │
│  │  │ NameServer │  │      │  │ NameServer │  │    │
│  │  └────────────┘  │      │  └────────────┘  │    │
│  │                  │      │                  │    │
│  │  ┌────────────┐  │      │  ┌────────────┐  │    │
│  │  │ Broker-A   │  │      │  │ Broker-B   │  │    │
│  │  │  (Master)  │◀─┼──────┼─>│  (Slave)   │  │    │
│  │  └────────────┘  │      │  └────────────┘  │    │
│  │                  │      │                  │    │
│  └──────────────────┘      └──────────────────┘    │
└─────────────────────────────────────────────────────┘
```

### 9.2 故障场景与处理

```
故障场景矩阵:

┌────────────────┬─────────────────┬─────────────────┐
│  故障类型      │  影响范围       │  恢复策略       │
├────────────────┼─────────────────┼─────────────────┤
│ Broker宕机     │ 单Broker        │ 主从切换(秒级)  │
│ Master宕机     │ 写入暂停        │ Slave升级Master │
│ Slave宕机      │ 无影响          │ 移除Slave       │
│ NameServer宕机 │ 单NS无影响      │ 客户端切换NS    │
│ 网络分区       │ 部分不可用      │ 多数派仲裁      │
│ 磁盘故障       │ 单盘数据丢失    │ 从Slave恢复     │
│ 机房故障       │ 单机房不可用    │ 跨机房容灾      │
└────────────────┴─────────────────┴─────────────────┘
```

### 9.3 数据容灾方案

```
容灾级别:

Level 1: 单机容灾
├─ 同步刷盘
├─ 数据持久化到磁盘
└─ RTO: 分钟级, RPO: 0

Level 2: 同机房容灾
├─ Master-Slave同步复制
├─ 同机房多副本
└─ RTO: 秒级, RPO: 0

Level 3: 跨机房容灾
├─ 跨机房异步复制
├─ 多机房部署
└─ RTO: 分钟级, RPO: 秒级

Level 4: 跨地域容灾
├─ 跨地域异步复制
├─ 多地域部署
└─ RTO: 小时级, RPO: 分钟级
```

### 9.4 限流与熔断

```
限流策略:

1. 生产限流
   ├─ TPS限流: 单Producer最大10000 TPS
   ├─ 流量限流: 单Producer最大100MB/s
   └─ 队列限流: 单Queue最大堆积1000万

2. 消费限流
   ├─ 拉取频率限流: 最快100ms/次
   ├─ 批量大小限流: 单次最多32条
   └─ 并发限流: 单Consumer最大64线程

熔断策略:

1. Broker熔断
   ├─ 触发条件: 失败率>50% 或 延迟>1s
   ├─ 熔断动作: 停止发送到该Broker
   ├─ 熔断时间: 30秒
   └─ 恢复策略: 半开状态探测

2. Consumer熔断
   ├─ 触发条件: 消费失败率>80%
   ├─ 熔断动作: 暂停消费
   ├─ 熔断时间: 60秒
   └─ 恢复策略: 降级消费
```

---

## 10. 性能优化方案

### 10.1 写入性能优化

```
优化手段:

1. 顺序写入
   ├─ CommitLog顺序追加
   ├─ 充分利用磁盘顺序写性能(600MB/s)
   └─ 避免随机IO

2. 批量写入
   ├─ 批量发送: 单次发送多条消息
   ├─ 批量刷盘: 积攒批量刷盘
   └─ 提升吞吐量5-10倍

3. 异步写入
   ├─ 异步发送: 不等待响应
   ├─ 异步刷盘: PageCache异步刷盘
   └─ 异步复制: 后台异步复制

4. 零拷贝
   ├─ MMap: 内存映射文件
   ├─ SendFile: 零拷贝传输
   └─ DirectBuffer: 直接内存

5. 文件预分配
   ├─ 启动时预分配CommitLog文件
   ├─ 避免动态扩展
   └─ 减少文件系统调用
```

### 10.2 读取性能优化

```
优化手段:

1. PageCache利用
   ├─ 热数据在PageCache
   ├─ 消费紧跟生产
   └─ 接近内存读取速度

2. 预读优化
   ├─ 顺序读取触发预读
   ├─ 一次读取多个消息
   └─ 减少IO次数

3. 消费并发
   ├─ 多队列并行消费
   ├─ 单队列多线程消费(顺序消息除外)
   └─ 提升消费吞吐量

4. 长轮询
   ├─ 减少空轮询
   ├─ 降低CPU消耗
   └─ 及时性与性能平衡

5. 消息过滤
   ├─ Broker端过滤
   ├─ 减少网络传输
   └─ 提升消费效率
```

### 10.3 内存优化

```
内存使用:

1. PageCache (系统自动管理)
   ├─ 最重要的性能因素
   ├─ 建议: 总内存的60-70%
   └─ 足够的PageCache = 接近内存速度

2. JVM堆内存 (无需JVM)
   ├─ Go自动垃圾回收
   ├─ 合理使用对象池
   └─ 避免频繁分配大对象

3. 直接内存
   ├─ MMap使用
   ├─ 网络传输Buffer
   └─ 减少内存拷贝

内存配置建议:
┌──────────────────┬─────────────────┐
│  服务器内存      │  建议配置       │
├──────────────────┼─────────────────┤
│  16GB            │ 4GB Process     │
│                 │ 12GB PageCache  │
├──────────────────┼─────────────────┤
│  32GB            │ 6GB Process     │
│                 │ 26GB PageCache  │
├──────────────────┼─────────────────┤
│  64GB            │ 12GB Process    │
│                 │ 52GB PageCache  │
└──────────────────┴─────────────────┘
```

---

## 11. 延时队列与定时任务设计 (参考 lmstfy)

### 11.1 延时队列架构设计

#### 11.1.1 lmstfy 延时队列核心思想

```
lmstfy (Let Me Schedule Tasks For You) 核心设计:

1. 基于Redis实现
2. 多级时间轮 + 有序集合
3. 支持秒级精度延时
4. 支持TTL和延时消息
5. 简单易用的HTTP API

LiteMQ 借鉴点:
├─ 时间轮分层设计
├─ 延时精度控制
├─ TTL过期机制
└─ 简洁的API设计
```

#### 11.1.2 多级延时队列设计

```
延时队列分层:

┌─────────────────────────────────────────────────────┐
│           延时队列多级调度架构                       │
├─────────────────────────────────────────────────────┤
│                                                      │
│  Level 1: 即时队列 (0-60秒)                         │
│  ┌────────────────────────────────────────────────┐ │
│  │  实现: 最小堆 (MinHeap)                        │ │
│  │  精度: 100ms                                   │ │
│  │  容量: 10万条                                  │ │
│  │  扫描: 100ms/次                                │ │
│  └────────────────────────────────────────────────┘ │
│           ↓ 超过60秒                                 │
│                                                      │
│  Level 2: 短期延时队列 (1分钟-1小时)                │
│  ┌────────────────────────────────────────────────┐ │
│  │  实现: 时间轮 (60槽 * 60秒)                   │ │
│  │  精度: 1秒                                     │ │
│  │  容量: 100万条                                 │ │
│  │  扫描: 1秒/次                                  │ │
│  └────────────────────────────────────────────────┘ │
│           ↓ 超过1小时                                │
│                                                      │
│  Level 3: 中期延时队列 (1小时-24小时)               │
│  ┌────────────────────────────────────────────────┐ │
│  │  实现: 时间轮 (24槽 * 1小时)                  │ │
│  │  精度: 1分钟                                   │ │
│  │  容量: 1000万条                                │ │
│  │  扫描: 1分钟/次                                │ │
│  └────────────────────────────────────────────────┘ │
│           ↓ 超过24小时                               │
│                                                      │
│  Level 4: 长期延时队列 (1天-30天)                   │
│  ┌────────────────────────────────────────────────┐ │
│  │  实现: 基于磁盘的B+树索引                      │ │
│  │  精度: 1小时                                   │ │
│  │  容量: 亿级                                    │ │
│  │  扫描: 1小时/次                                │ │
│  └────────────────────────────────────────────────┘ │
│                                                      │
└─────────────────────────────────────────────────────┘
```

#### 11.1.3 延时消息状态机

```
延时消息生命周期:

Created ──> Delayed ──> Ready ──> Reserved ──> Deleted
              │           │         │
              │           │         └──> Timeout ──> Ready
              │           │                         (重新可消费)
              │           └──> Consumed ──> Deleted
              │
              └──> TTL Expired ──> Deleted

状态说明:
- Created: 消息创建
- Delayed: 延时等待中
- Ready: 到期可消费
- Reserved: 消费中(锁定)
- Consumed: 已消费
- Deleted: 已删除
- TTL Expired: 超时过期
```

#### 11.1.4 延时消息数据结构

```go
// 延时消息
type DelayMessage struct {
    ID            string            // 消息ID
    Topic         string            // 主题
    Body          []byte            // 消息体
    Delay         int64             // 延时秒数
    DeadlineAt    int64             // 到期时间戳
    TTL           int64             // 生存时间(秒)
    CreatedAt     int64             // 创建时间
    RetryCount    int               // 重试次数
    MaxRetry      int               // 最大重试
    Status        DelayStatus       // 状态
    Properties    map[string]string // 属性
}

// 延时队列管理器
type DelayQueueManager struct {
    // Level 1: 即时队列
    immediateQueue *MinHeap
    
    // Level 2: 短期延时
    shortTermWheel *TimeWheel  // 60秒 * 60槽
    
    // Level 3: 中期延时
    mediumTermWheel *TimeWheel // 60分钟 * 24槽
    
    // Level 4: 长期延时
    longTermIndex *BTreeIndex  // 磁盘B+树
    
    // TTR (Time To Reserve) 超时检测
    reservedMessages map[string]*ReservedMessage
    
    // 死信队列
    deadLetterQueue *DeadLetterQueue
}
```

#### 11.1.5 延时队列核心算法

```
延时消息插入算法:

func (dqm *DelayQueueManager) AddDelayMessage(msg *DelayMessage) error {
    delay := msg.DeadlineAt - time.Now().Unix()
    
    switch {
    case delay <= 60:
        // 0-60秒: 放入即时队列
        return dqm.immediateQueue.Push(msg)
        
    case delay <= 3600:
        // 1分钟-1小时: 放入短期时间轮
        slot := (delay / 1) % 3600
        return dqm.shortTermWheel.Add(slot, msg)
        
    case delay <= 86400:
        // 1小时-24小时: 放入中期时间轮
        slot := (delay / 60) % 1440
        return dqm.mediumTermWheel.Add(slot, msg)
        
    default:
        // 超过24小时: 放入长期索引
        return dqm.longTermIndex.Insert(msg.DeadlineAt, msg)
    }
}

延时消息扫描算法:

func (dqm *DelayQueueManager) Scan() {
    // Level 1: 100ms扫描一次
    go dqm.scanImmediate(100 * time.Millisecond)
    
    // Level 2: 1秒扫描一次
    go dqm.scanShortTerm(1 * time.Second)
    
    // Level 3: 1分钟扫描一次
    go dqm.scanMediumTerm(1 * time.Minute)
    
    // Level 4: 1小时扫描一次
    go dqm.scanLongTerm(1 * time.Hour)
}

延时消息降级算法:

func (dqm *DelayQueueManager) Demote() {
    // 长期 -> 中期
    messages := dqm.longTermIndex.GetExpiringSoon(24 * time.Hour)
    for _, msg := range messages {
        dqm.mediumTermWheel.Add(msg)
        dqm.longTermIndex.Delete(msg.ID)
    }
    
    // 中期 -> 短期
    messages := dqm.mediumTermWheel.GetExpiringSoon(1 * time.Hour)
    for _, msg := range messages {
        dqm.shortTermWheel.Add(msg)
        dqm.mediumTermWheel.Remove(msg.ID)
    }
    
    // 短期 -> 即时
    messages := dqm.shortTermWheel.GetExpiringSoon(60)
    for _, msg := range messages {
        dqm.immediateQueue.Push(msg)
        dqm.shortTermWheel.Remove(msg.ID)
    }
}
```

### 11.2 定时任务设计

#### 11.2.1 Cron 定时任务架构

```
┌─────────────────────────────────────────────────────┐
│              Cron定时任务管理器                      │
├─────────────────────────────────────────────────────┤
│                                                      │
│  ┌────────────────────────────────────────────────┐ │
│  │  Cron表达式解析器                              │ │
│  │  - 支持标准Cron: * * * * * *                  │ │
│  │  - 秒 分 时 日 月 周                           │ │
│  │  - 支持范围: 1-5                              │ │
│  │  - 支持间隔: */10                             │ │
│  │  - 支持列表: 1,2,3                            │ │
│  └────────────────────────────────────────────────┘ │
│                     ↓                                │
│  ┌────────────────────────────────────────────────┐ │
│  │  任务调度引擎                                  │ │
│  │  - 最小堆维护任务列表                          │ │
│  │  - 按下次执行时间排序                          │ │
│  │  - 定时扫描到期任务                            │ │
│  │  - 并发执行任务                                │ │
│  └────────────────────────────────────────────────┘ │
│                     ↓                                │
│  ┌────────────────────────────────────────────────┐ │
│  │  任务执行器                                    │ │
│  │  - 创建消息                                    │ │
│  │  - 发送到Topic                                 │ │
│  │  - 更新下次执行时间                            │ │
│  │  - 记录执行历史                                │ │
│  └────────────────────────────────────────────────┘ │
│                                                      │
└─────────────────────────────────────────────────────┘
```

#### 11.2.2 Cron 任务数据结构

```go
// Cron任务
type CronJob struct {
    JobID         string            // 任务ID
    JobName       string            // 任务名称
    Topic         string            // 目标Topic
    CronExpr      string            // Cron表达式
    Payload       []byte            // 消息载荷
    Enabled       bool              // 是否启用
    Timezone      string            // 时区
    NextRunTime   int64             // 下次执行时间
    LastRunTime   int64             // 上次执行时间
    RunCount      int64             // 执行次数
    FailCount     int64             // 失败次数
    MaxRetry      int               // 最大重试
    Timeout       int64             // 执行超时(秒)
    Properties    map[string]string // 任务属性
    CreatedAt     int64             // 创建时间
}

// Cron调度器
type CronScheduler struct {
    jobs          map[string]*CronJob  // 任务表
    jobHeap       *JobHeap             // 任务最小堆
    runningJobs   map[string]bool      // 运行中任务
    executor      *JobExecutor         // 任务执行器
    stopCh        chan struct{}        // 停止信号
}

// Cron表达式
type CronExpression struct {
    Second      []int  // 0-59
    Minute      []int  // 0-59
    Hour        []int  // 0-23
    DayOfMonth  []int  // 1-31
    Month       []int  // 1-12
    DayOfWeek   []int  // 0-6 (0=Sunday)
}
```

#### 11.2.3 Cron 调度算法

```
Cron调度核心流程:

1. 任务注册
   ├─ 解析Cron表达式
   ├─ 计算下次执行时间
   ├─ 加入任务最小堆
   └─ 持久化任务信息

2. 任务调度
   ├─ 每秒扫描堆顶
   ├─ 检查是否到期
   ├─ 到期则触发执行
   └─ 重新计算下次时间

3. 任务执行
   ├─ 并发执行(Worker池)
   ├─ 构造消息体
   ├─ 发送到Topic
   ├─ 记录执行结果
   └─ 失败自动重试

4. 任务持久化
   ├─ 任务配置持久化
   ├─ 执行历史持久化
   ├─ 支持崩溃恢复
   └─ 避免重复执行

算法示例:

func (cs *CronScheduler) Schedule() {
    ticker := time.NewTicker(1 * time.Second)
    defer ticker.Stop()
    
    for {
        select {
        case <-cs.stopCh:
            return
        case now := <-ticker.C:
            // 扫描到期任务
            for {
                job := cs.jobHeap.Peek()
                if job == nil || job.NextRunTime > now.Unix() {
                    break
                }
                
                // 弹出任务
                job = cs.jobHeap.Pop()
                
                // 异步执行
                go cs.executor.Execute(job)
                
                // 计算下次执行时间
                nextTime := cs.calculateNextTime(job, now)
                job.NextRunTime = nextTime
                
                // 重新入堆
                cs.jobHeap.Push(job)
            }
        }
    }
}

func (cs *CronScheduler) calculateNextTime(job *CronJob, from time.Time) int64 {
    expr := ParseCronExpr(job.CronExpr)
    
    // 从当前时间开始,找到下一个匹配的时间点
    t := from.Add(1 * time.Second)
    maxAttempts := 4 * 365 * 24 * 3600  // 最多4年
    
    for i := 0; i < maxAttempts; i++ {
        if cs.matchCronExpr(expr, t) {
            return t.Unix()
        }
        t = t.Add(1 * time.Second)
    }
    
    return from.Add(24 * time.Hour).Unix()
}
```

#### 11.2.4 大规模离线定时任务支持

```
场景: 支持百万级定时推送任务

架构设计:

┌─────────────────────────────────────────────────────┐
│         大规模定时任务调度架构                       │
├─────────────────────────────────────────────────────┤
│                                                      │
│  1. 任务分片                                         │
│  ┌────────────────────────────────────────────────┐ │
│  │  任务按时间分片: 每小时一个分片                │ │
│  │  Shard-0: 00:00-00:59 (10万任务)              │ │
│  │  Shard-1: 01:00-01:59 (15万任务)              │ │
│  │  Shard-2: 02:00-02:59 (8万任务)               │ │
│  │  ...                                           │ │
│  └────────────────────────────────────────────────┘ │
│                                                      │
│  2. 预加载机制                                       │
│  ┌────────────────────────────────────────────────┐ │
│  │  提前10分钟加载下一小时任务到内存              │ │
│  │  使用时间轮存储                                │ │
│  │  减少磁盘IO                                    │ │
│  └────────────────────────────────────────────────┘ │
│                                                      │
│  3. 并发执行                                         │
│  ┌────────────────────────────────────────────────┐ │
│  │  Worker池并发执行                              │ │
│  │  单Broker支持1000+ QPS触发                     │ │
│  │  多Broker水平扩展                              │ │
│  └────────────────────────────────────────────────┘ │
│                                                      │
│  4. 故障恢复                                         │
│  ┌────────────────────────────────────────────────┐ │
│  │  执行状态持久化                                │ │
│  │  崩溃后自动重新加载                            │ │
│  │  幂等性保证(去重)                              │ │
│  └────────────────────────────────────────────────┘ │
│                                                      │
└─────────────────────────────────────────────────────┘

性能优化:

1. 内存索引
   ├─ 时间轮 + 跳表
   ├─ O(1)插入和查询
   └─ 支持百万级任务

2. 批量触发
   ├─ 同一秒的任务批量处理
   ├─ 批量发送消息
   └─ 提升10倍吞吐

3. 异步持久化
   ├─ 执行状态异步写入
   ├─ 批量刷盘
   └─ 减少IO影响

4. 分布式调度
   ├─ 任务按Hash分配到不同Broker
   ├─ 避免单点瓶颈
   └─ 水平扩展
```

### 11.3 死信队列设计

#### 11.3.1 死信队列架构

```
┌─────────────────────────────────────────────────────┐
│               死信队列(DLQ)架构                      │
├─────────────────────────────────────────────────────┤
│                                                      │
│  触发条件:                                           │
│  ├─ 消费失败超过最大重试次数                         │
│  ├─ 消息过期(TTL)                                    │
│  ├─ 队列长度超限(溢出)                               │
│  └─ 消费异常无法处理                                 │
│                                                      │
│  ┌────────────────────────────────────────────────┐ │
│  │  死信消息存储                                  │ │
│  │  Topic: %DLQ%原始Topic                         │ │
│  │  保留原始消息全部信息                          │ │
│  │  附加死信原因和上下文                          │ │
│  └────────────────────────────────────────────────┘ │
│                                                      │
│  ┌────────────────────────────────────────────────┐ │
│  │  死信处理策略                                  │ │
│  │  1. 人工介入: 查看原因,修复数据               │ │
│  │  2. 重新投递: 修复后重新投递到原Topic         │ │
│  │  3. 归档存储: 长期保存用于审计                │ │
│  │  4. 自动清理: 超过保留期自动删除              │ │
│  └────────────────────────────────────────────────┘ │
│                                                      │
└─────────────────────────────────────────────────────┘
```

#### 11.3.2 死信消息结构

```go
// 死信消息
type DeadLetterMessage struct {
    // 原始消息
    OriginalMessage *Message
    
    // 死信信息
    DeadReason      DeadReason    // 死信原因
    DeadTime        int64         // 进入死信时间
    RetryCount      int           // 重试次数
    LastError       string        // 最后错误
    ConsumerGroup   string        // 消费组
    ConsumerID      string        // 消费者ID
    
    // 上下文
    StackTrace      string        // 异常堆栈
    Properties      map[string]string
}

// 死信原因
type DeadReason int

const (
    DeadReasonMaxRetry      DeadReason = 1  // 超过最大重试
    DeadReasonTTLExpired    DeadReason = 2  // TTL过期
    DeadReasonQueueFull     DeadReason = 3  // 队列溢出
    DeadReasonConsumeError  DeadReason = 4  // 消费异常
    DeadReasonFilterOut     DeadReason = 5  // 过滤丢弃
)
```

#### 11.3.3 死信处理流程

```
死信处理完整流程:

1. 消费失败检测
   │
   ├─> 判断重试次数
   │   ├─ < MaxRetry: 进入重试队列
   │   └─ >= MaxRetry: 进入死信流程
   │
   ↓
2. 构造死信消息
   ├─ 复制原始消息
   ├─ 添加死信元数据
   ├─ 记录失败原因
   └─ 保存异常信息
   │
   ↓
3. 写入死信Topic
   ├─ Topic命名: %DLQ%{OriginalTopic}
   ├─ 持久化存储
   └─ 触发告警通知
   │
   ↓
4. 从原队列移除
   ├─ 确认消费(ACK)
   ├─ 更新消费进度
   └─ 释放资源
   │
   ↓
5. 死信监控
   ├─ 死信数量监控
   ├─ 告警通知
   └─ 人工介入
```

---

## 12. 监控与运维

### 12.1 监控指标体系

```
监控指标分类:

1. Broker指标
   ├─ TPS: 消息发送/消费TPS
   ├─ 延迟: P50/P95/P99延迟
   ├─ 队列堆积: 各Topic堆积量
   ├─ 磁盘使用: CommitLog/ConsumeQueue大小
   ├─ 内存使用: PageCache命中率
   └─ 网络流量: 入/出流量

2. Topic指标
   ├─ 消息生产速率
   ├─ 消息消费速率
   ├─ 消息堆积量
   ├─ 消费延迟
   └─ 死信数量

3. Consumer指标
   ├─ 消费TPS
   ├─ 消费延迟
   ├─ 消费失败率
   ├─ 重试次数
   └─ 队列分配情况

4. 系统指标
   ├─ CPU使用率
   ├─ 内存使用率
   ├─ 磁盘IO
   ├─ 网络IO
   └─ 线程/协程数

5. 业务指标
   ├─ 事务消息成功率
   ├─ 延时消息准确率
   ├─ Cron任务执行率
   └─ 主从复制延迟
```

### 12.2 告警规则

```
告警级别:

P0 (紧急):
├─ Broker宕机
├─ Master下线
├─ 磁盘满
└─ 消息大量丢失

P1 (重要):
├─ 队列堆积超过100万
├─ 消费延迟超过10分钟
├─ 死信数量激增
└─ 主从复制延迟超过60秒

P2 (一般):
├─ 消费失败率超过10%
├─ TPS下降50%
├─ 磁盘使用超过80%
└─ Slave下线

P3 (提示):
├─ 队列堆积超过10万
├─ 消费延迟超过1分钟
└─ 内存使用超过70%
```

### 12.3 运维工具

```
运维工具集:

1. CLI工具 (litemq-admin)
   ├─ 集群管理: 查看集群状态
   ├─ Topic管理: 创建/删除/查询Topic
   ├─ 消息查询: 按ID/Key/时间查询
   ├─ 消费组管理: 重置消费进度
   ├─ 性能测试: 压测工具
   └─ 数据迁移: 导入/导出

2. Web控制台
   ├─ Dashboard: 集群总览
   ├─ 监控图表: 实时指标
   ├─ 告警中心: 告警查看/配置
   ├─ 消息追踪: 消息全链路追踪
   └─ 配置管理: 在线配置修改

3. SDK
   ├─ Go SDK
   ├─ Java SDK
   ├─ Python SDK
   └─ Node.js SDK
```

---

## 13. 项目结构设计

### 13.1 目录结构

```
litemq/
├── cmd/                          # 命令行工具
│   ├── broker/                   # Broker启动入口
│   │   └── main.go
│   ├── nameserver/               # NameServer启动入口
│   │   └── main.go
│   ├── admin/                    # 管理工具
│   │   └── main.go
│   └── benchmark/                # 性能测试工具
│       └── main.go
│
├── pkg/                          # 核心包
│   ├── nameserver/               # NameServer实现
│   │   ├── nameserver.go         # 核心逻辑
│   │   ├── route.go              # 路由管理
│   │   ├── heartbeat.go          # 心跳处理
│   │   └── failover.go           # 故障切换
│   │
│   ├── broker/                   # Broker实现
│   │   ├── broker.go             # Broker核心
│   │   ├── message_handler.go    # 消息处理
│   │   ├── consumer_manager.go   # 消费者管理
│   │   └── replication.go        # 主从复制
│   │
│   ├── storage/                  # 存储引擎
│   │   ├── commitlog/            # CommitLog
│   │   │   ├── commitlog.go
│   │   │   ├── mappedfile.go
│   │   │   └── flush.go
│   │   ├── consumequeue/         # ConsumeQueue
│   │   │   ├── consumequeue.go
│   │   │   └── builder.go
│   │   ├── index/                # 索引文件
│   │   │   └── indexfile.go
│   │   └── checkpoint/           # 检查点
│   │       └── checkpoint.go
│   │
│   ├── delay/                    # 延时队列
│   │   ├── delay_manager.go      # 延时管理器
│   │   ├── minheap.go            # 最小堆
│   │   ├── timewheel.go          # 时间轮
│   │   └── btree_index.go        # B树索引
│   │
│   ├── cron/                     # 定时任务
│   │   ├── cron_scheduler.go     # 调度器
│   │   ├── cron_parser.go        # 表达式解析
│   │   ├── job_executor.go       # 任务执行器
│   │   └── job_storage.go        # 任务存储
│   │
│   ├── transaction/              # 事务消息
│   │   ├── transaction_manager.go # 事务管理
│   │   ├── half_message.go       # Half消息
│   │   ├── checkback.go          # 回查机制
│   │   └── op_message.go         # Op消息
│   │
│   ├── broadcast/                # 广播消息
│   │   ├── broadcast_manager.go  # 广播管理
│   │   └── consumer_queue.go     # 消费者队列
│   │
│   ├── deadletter/               # 死信队列
│   │   ├── dlq_manager.go        # DLQ管理器
│   │   ├── dead_message.go       # 死信消息
│   │   └── recovery.go           # 恢复处理
│   │
│   ├── client/                   # 客户端SDK
│   │   ├── producer/             # 生产者
│   │   │   ├── producer.go
│   │   │   └── batch_producer.go
│   │   └── consumer/             # 消费者
│   │       ├── push_consumer.go
│   │       └── pull_consumer.go
│   │
│   ├── protocol/                 # 协议定义
│   │   ├── api.proto             # gRPC协议
│   │   ├── message.go            # 消息定义
│   │   └── command.go            # 命令定义
│   │
│   ├── monitor/                  # 监控
│   │   ├── metrics.go            # 指标收集
│   │   ├── exporter.go           # Prometheus导出
│   │   └── tracing.go            # 链路追踪
│   │
│   └── common/                   # 公共组件
│       ├── config/               # 配置管理
│       ├── util/                 # 工具函数
│       ├── log/                  # 日志
│       └── errors/               # 错误定义
│
├── internal/                     # 内部包
│   ├── server/                   # 服务端实现
│   └── tools/                    # 内部工具
│
├── api/                          # API定义
│   ├── grpc/                     # gRPC API
│   └── http/                     # HTTP API
│
├── web/                          # Web控制台
│   ├── frontend/                 # 前端
│   └── backend/                  # 后端
│
├── configs/                      # 配置文件
│   ├── broker.toml              # Broker配置
│   ├── nameserver.toml          # NameServer配置
│   └── client.toml              # 客户端配置
│
├── scripts/                      # 脚本
│   ├── build.sh                 # 构建脚本
│   ├── deploy.sh                # 部署脚本
│   └── test.sh                  # 测试脚本
│
├── docs/                         # 文档
│   ├── architecture.md          # 架构文档
│   ├── quickstart.md            # 快速开始
│   ├── api.md                   # API文档
│   └── ops.md                   # 运维文档
│
├── examples/                     # 示例代码
│   ├── producer/                # 生产者示例
│   ├── consumer/                # 消费者示例
│   ├── transaction/             # 事务消息示例
│   └── delay/                   # 延时消息示例
│
├── test/                         # 测试
│   ├── unit/                    # 单元测试
│   ├── integration/             # 集成测试
│   └── benchmark/               # 性能测试
│
├── deployments/                  # 部署文件
│   ├── docker/                  # Docker
│   ├── kubernetes/              # K8s
│   └── systemd/                 # Systemd
│
├── go.mod                        # Go模块
├── go.sum
├── Makefile                      # Make文件
├── README.md                     # 项目说明
└── LICENSE                       # 许可证
```

### 13.2 模块依赖关系

```
模块依赖图:

                    ┌──────────────┐
                    │  NameServer  │
                    └──────┬───────┘
                           │
                    ┌──────▼───────┐
                    │    Broker    │
                    └──────┬───────┘
                           │
        ┌──────────────────┼──────────────────┐
        │                  │                  │
        ▼                  ▼                  ▼
┌──────────────┐   ┌──────────────┐   ┌──────────────┐
│ Transaction  │   │    Delay     │   │  Broadcast   │
│   Manager    │   │   Manager    │   │   Manager    │
└──────┬───────┘   └──────┬───────┘   └──────┬───────┘
       │                  │                  │
       └──────────────────┼──────────────────┘
                          │
                  ┌───────▼────────┐
                  │  Storage Layer │
                  └────────────────┘
                          │
        ┌─────────────────┼─────────────────┐
        ▼                 ▼                 ▼
┌──────────────┐  ┌──────────────┐  ┌──────────────┐
│  CommitLog   │  │ConsumeQueue  │  │  IndexFile   │
└──────────────┘  └──────────────┘  └──────────────┘
```

---
